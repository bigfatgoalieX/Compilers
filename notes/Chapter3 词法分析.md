# Chapter 3 词法分析

## 词法分析器的作用

- 读入字符流，组成词素，输出**词法单元**序列

- 过滤空白、换行、制表符、注释等

- 将词素添加到符号表中

- 在逻辑上独立于语法分析，但是通常和语法分析器处于同一**趟**中

  > 趟（pass）：每趟读入一个输入文件，产生一个输出文件	

##### 既然是一趟，为什么要设立独立的词法分析器？

- 简化编译器设计（先把最简单的处理了）
- 提高编译器效率（词法分析比语法分析简单，可以高效实现（PDA&DFA））

- 增强编译器的可移植性

##### 词法单元（token）、模式（pattern）、词素（lexeme）

- 词法单元
  $$
  <词法单元名(token-name)，属性值（可选）(attribute-value)>
  $$
  单元名是表示词法单位**种类**的抽象符号，之后的语法分析器通过单元名即可确定词法单元序列的结构；属性值通常用于语义分析后的阶段。

  当一个模式匹配多个词素时，属性值被用于传递附加的信息。属性值将被用于语义分析、代码生成等阶段。不同的目的往往需要不同的属性：

  > 以词法单元名id为例，属性中可能要涵盖的信息包括：词素、类型、第一次出现的位置...

  所以属性值通常是一个结构化数据（struct）。

  ```C
  typedef struct attribute_value_type{
  }Attribute_T
  ```

- 模式

  描述了一类词法单元的词素可能具有的形式

  > 以i词法单元id为例，模式的（非正式）描述是，以字母开头的字母/数字串

- 词素

  来自源程序中的字符序列；它与某个词法单元的模式成功匹配，被词法分析器识别为该词法单元的实例。

## 词法单元的规约（正则表达式，RE）

正则表达式可以高效、简洁地描述处理词法单元时用到的**模式**类型。在形式语言与自动机课程中我们学过RE的内容，现在发现RE在描述某种字符串模式时很有用，下面给出一个例子：
$$
letter \to A|B| \cdots |Z|a|b| \cdots |z| \\
digit \to 0|1|2| \cdots |9| \\ 
id \to letter(letter + digit)^{*}
$$

## 词法单元的识别（状态转换图）

词法分析器要求能够检查输入字符串，在其**前缀**中找出和某个模式匹配的词素。

- 保留字（或称关键字）和标识符的区别

  很多时候，保留字符合标识符的模式。

  可能的解决方案是，在符号表中先填写保留字，并且指明它们不是普通标识符。并为保留字建立独立的、高优先级的状态转换图。

- 词法分析器的体系结构

  实际就是用代码模拟转换图的运行。

- 处理多个模式的方法

  词法分析器显然需要匹配多个模式，可能的解决方法：

  - 按照优先级，顺序地尝试各个状态转换图，如果引发 fail()，回退并尝试下一个状态图
  - 更好的方法：并行地运行各个状态转换图；通过 贪心策略，识别最长的与某个模式匹配的输入前缀
  - **实际使用的方法**：预先把各个状态转换图**合成一个状态转换图**，然后运行这个状态转换图 (后面介绍)

## 词法分析器生成工具及设计

$$
lex.l \overset{Lex编译器}{\to} lex.yy.c \overset{C编译器}{\to} a.out \\
输入流 \overset{a.out}{\to} 词法单元的序列
$$

## 有穷自动机

正则表达式可以简洁精确地描述词法单元的模式，模拟DFA的执行可以高效地进行模式匹配，转换：
$$
RE \to NFA \to DFA
$$
词法分析器构造自动机：
$$
各个模式RE\overset{}{\to} 各个模式NFA \overset{合并}{\to} NFA \to DFA (或许DFA最小化)
$$
