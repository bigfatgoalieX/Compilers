# Chapter 1 引论

- 编译器（compiler）

  读入某种语言编写的程序，输出（等价的）用另一种语言编写的程序。通常输出的目标程序是可执行的（executable）

- 解释器（interpreter）

  直接利用输入执行源程序中的指定操作，不用生成目标程序

    > C/C++前者；python后者；Java的处理结合了编译和解释

- 编译器的结构

  分析（前端）+  综合（后端）

  分析（analysis）把源程序分解成组成要素，以及相应的语法结构，使用这个结构创建源程序的中间表示；与此同时收集和源程序相关的信息，存放到符号表里

  综合（synthesis）根据**中间表示**和**符号表**来构建目标程序

  > 前端机器无关，后端机器相关

- 字符流->（词法分析器）->符号流->（语法分析）->语法树->（语义分析）->语法树

  符号表搁一边

- 词法分析（lexical analysis）

  输入源程序的字符流，输出有意义的词素（lexeme）
  $$
  <token-name, attribute-value>
  $$
  token-name由语法分析步骤使用，attribute-value指向相应的符号表条目，由语义分析/代码生成步骤使用。

- 语法分析（syntax analysis）

  根据上面词法分析中提到的第一个分量token-name来创建树型中间表示形式，通常是语法树（syntax tree）中间表示形式指出了词法单元流的语法结构。

- 语义分析（semantic analysis）

  使用语法树和符号表中的信息，检索源程序是否满足语言定义的语义约束；同时收集类型信息，用于代码生成、类型检查、类型转换

- 符号表管理

  记录源程序中使用的变量的名字，收集各种属性

- 编译器构造工具

  扫描器（Lex）、语法分析器（Yacc）、语法制导的翻译引擎...

- 程序设计语言的发展历程
  1. 第一代：机器语言
  2. 第二代：汇编语言（宏命令）
  3. 第三代：Fortran、Cobol、Lisp、C、Cpp
  4. 第四代：特定应用语言NOMAD、SQL、Postscript
  5. 第五代：基于逻辑和约束的语言Prolog、OPS5

- 强制式语言（imperative）/声明式语言（declarative）

  强制式，又称命令式，是强制计算机硬件进行指定操作的编程语言，**贴近硬件**；声明式，只是提出我要干什么，而不说怎么干，剩下的全部甩给计算机处理，**贴近现实**。